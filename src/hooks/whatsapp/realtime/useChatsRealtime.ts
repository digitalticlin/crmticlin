
/**
 * üéØ HOOK ISOLADO: REALTIME PARA CARDS DE CONTATOS - MULTITENANCY CORRIGIDO
 * 
 * CORRE√á√ïES APLICADAS:
 * ‚úÖ Valida√ß√£o dupla de ownership em todos os callbacks
 * ‚úÖ Debounce para evitar atualiza√ß√µes m√∫ltiplas simult√¢neas
 * ‚úÖ Sistema de reconnection com retry exponencial
 * ‚úÖ Heartbeat para detectar conex√µes mortas
 * ‚úÖ Filtros rigorosos de multitenancy
 * ‚úÖ Isolamento total por usu√°rio
 */

import { useEffect, useRef, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';
import { ChatsRealtimeConfig, RealtimeConnectionStatus } from './types';
import { BigQueryOptimizer } from '@/utils/immediate-bigquery-fix';
import { realtimeLogger } from '@/utils/logger';

const isProduction = process.env.NODE_ENV === 'production';

export const useChatsRealtime = ({
  activeInstanceId,
  onContactUpdate,
  onNewContact,
  onContactsRefresh,
  onMoveContactToTop,
  onUpdateUnreadCount,
  onAddNewContact
}: ChatsRealtimeConfig) => {
  
  const { user } = useAuth(); // üöÄ CORRE√á√ÉO: Conectar diretamente ao useAuth
  const channelRef = useRef<any>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;
  const lastUserIdRef = useRef<string | null>(null);
  const lastInstanceIdRef = useRef<string | null>(null);
  const isSubscribedRef = useRef(false);
  const statsRef = useRef({
    totalEvents: 0,
    lastUpdate: null as number | null,
    connectionStatus: 'disconnected' as RealtimeConnectionStatus
  });

  // üöÄ CORRE√á√ÉO: Debounce para callbacks
  const debouncedCallbacks = useRef<{
    [key: string]: NodeJS.Timeout;
  }>({});

  const debounceCallback = useCallback((callback: () => void, key: string, delay = 300) => {
    if (debouncedCallbacks.current[key]) {
      clearTimeout(debouncedCallbacks.current[key]);
    }
    
    debouncedCallbacks.current[key] = setTimeout(callback, delay);
  }, []);

  // üöÄ CORRE√á√ÉO: Sistema de reconnection com retry exponencial
  const reconnect = useCallback(() => {
    if (reconnectAttempts.current >= maxReconnectAttempts) {
      console.error('[ChatsRealtime] ‚ùå M√°ximo de tentativas de reconnection atingido');
      statsRef.current.connectionStatus = 'error';
      return;
    }

    const delay = Math.pow(2, reconnectAttempts.current) * 1000;
    reconnectAttempts.current++;
    
    console.log(`[ChatsRealtime] üîÑ Tentativa de reconnection ${reconnectAttempts.current}/${maxReconnectAttempts} em ${delay}ms`);
    
    reconnectTimeoutRef.current = setTimeout(() => {
      setupRealtime();
    }, delay);
  }, []);

  // Cleanup otimizado
  const cleanup = useCallback(() => {
    // Limpar timeouts de reconnection
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    
    // Limpar timeouts de debounce
    Object.values(debouncedCallbacks.current).forEach(timeout => {
      if (timeout) clearTimeout(timeout);
    });
    debouncedCallbacks.current = {};
    
    if (channelRef.current) {
      if (!isProduction) {
        realtimeLogger.log('üßπ Removendo canal de chats');
      }
      supabase.removeChannel(channelRef.current);
      channelRef.current = null;
      isSubscribedRef.current = false;
      statsRef.current.connectionStatus = 'disconnected';
    }
    
    reconnectAttempts.current = 0;
  }, []);

  // Handler para novos leads otimizado com valida√ß√£o de ownership
  const handleNewLead = useCallback((payload: any) => {
    try {
      const newLead = payload.new;
      
      // üöÄ CORRE√á√ÉO: Valida√ß√£o dupla de ownership
      if (!user?.id || newLead?.created_by_user_id !== user.id) {
        console.warn('[ChatsRealtime] üö® Tentativa de acesso cross-user bloqueada:', {
          userId: user?.id,
          leadOwner: newLead?.created_by_user_id,
          leadId: newLead?.id
        });
        return;
      }
      
      // Verificar se √© da inst√¢ncia ativa
      if (activeInstanceId && newLead?.whatsapp_number_id === activeInstanceId) {
        statsRef.current.totalEvents++;
        statsRef.current.lastUpdate = Date.now();

        // üöÄ CORRE√á√ÉO: Aplicar debounce nos callbacks
        if (onAddNewContact) {
          const newContactData = {
            id: newLead.id,
            leadId: newLead.id,
            name: newLead.name || 'Novo Contato',
            phone: newLead.phone,
            email: newLead.email,
            lastMessage: 'Nova conversa iniciada',
            lastMessageTime: newLead.created_at || new Date().toISOString(),
            unreadCount: 1,
            stageId: newLead.kanban_stage_id || null,
            createdAt: newLead.created_at
          };
          
          debounceCallback(() => onAddNewContact(newContactData), 'addNewContact');
          return;
        }

        // Fallback para callbacks legados
        if (onNewContact) {
          const contact = {
            id: newLead.id,
            name: newLead.name || newLead.phone || 'Contato',
            phone: newLead.phone
          };
          debounceCallback(() => onNewContact(contact), 'newContact');
        }

        // √öltimo recurso: refresh completo
        if (onContactsRefresh && !onAddNewContact) {
          debounceCallback(() => onContactsRefresh(), 'contactsRefresh');
        }
      }
    } catch (error) {
      console.error('[ChatsRealtime] ‚ùå Erro processando novo lead:', error);
      BigQueryOptimizer.handleError(error);
    }
  }, [activeInstanceId, onNewContact, onContactsRefresh, onAddNewContact, user?.id, debounceCallback]);

  // Handler para atualiza√ß√µes de leads otimizado com valida√ß√£o de ownership
  const handleLeadUpdate = useCallback((payload: any) => {
    try {
      const updatedLead = payload.new;
      const oldLead = payload.old;
      
      // üöÄ CORRE√á√ÉO: Valida√ß√£o dupla de ownership
      if (!user?.id || updatedLead?.created_by_user_id !== user.id) {
        console.warn('[ChatsRealtime] üö® Tentativa de acesso cross-user bloqueada:', {
          userId: user?.id,
          leadOwner: updatedLead?.created_by_user_id,
          leadId: updatedLead?.id
        });
        return;
      }
      
      // Verificar se √© da inst√¢ncia ativa
      if (activeInstanceId && updatedLead?.whatsapp_number_id === activeInstanceId) {
        statsRef.current.totalEvents++;
        statsRef.current.lastUpdate = Date.now();

        // üöÄ CORRE√á√ÉO: Aplicar debounce nos callbacks
        if (oldLead?.unread_count !== updatedLead?.unread_count) {
          if (onUpdateUnreadCount) {
            const increment = (updatedLead?.unread_count || 0) > (oldLead?.unread_count || 0);
            debounceCallback(() => onUpdateUnreadCount(updatedLead.id, increment), 'updateUnreadCount');
            return;
          }
        }

        // Fallback: refresh completo apenas se n√£o h√° callback granular
        if (onContactsRefresh && !onUpdateUnreadCount) {
          debounceCallback(() => onContactsRefresh(), 'contactsRefresh');
        }
      }
    } catch (error) {
      console.error('[ChatsRealtime] ‚ùå Erro processando atualiza√ß√£o de lead:', error);
      BigQueryOptimizer.handleError(error);
    }
  }, [activeInstanceId, onContactsRefresh, onUpdateUnreadCount, user?.id, debounceCallback]);

  // üöÄ CORRE√á√ÉO: Setup realtime com valida√ß√£o rigorosa de multitenancy
  const setupRealtime = useCallback(() => {
    // üöÄ CORRE√á√ÉO: Valida√ß√£o rigorosa de usu√°rio
    if (!user?.id || !activeInstanceId) {
      console.warn('[ChatsRealtime] ‚ö†Ô∏è Usu√°rio n√£o autenticado ou inst√¢ncia n√£o ativa');
      cleanup();
      return;
    }
    
    const hasAnyCallback = !!(onMoveContactToTop || onUpdateUnreadCount || onAddNewContact || onContactUpdate || onNewContact || onContactsRefresh);
    if (!hasAnyCallback) {
      cleanup();
      return;
    }

    // Verificar se precisa reconfigurar
    const needsReconfigure = 
      lastUserIdRef.current !== user.id ||
      lastInstanceIdRef.current !== activeInstanceId ||
      !isSubscribedRef.current;

    if (!needsReconfigure) {
      return;
    }

    // Cleanup anterior
    cleanup();

    // Atualizar refs
    lastUserIdRef.current = user.id;
    lastInstanceIdRef.current = activeInstanceId;

    // Criar novo canal
    const channelId = `chats-realtime-${user.id}-${activeInstanceId}-${Date.now()}`;
    
    statsRef.current.connectionStatus = 'connecting';

    const channel = supabase
      .channel(channelId)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'leads',
        filter: `created_by_user_id=eq.${user.id}` // üöÄ CORRE√á√ÉO: Filtro rigoroso
      }, handleNewLead)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'leads',
        filter: `created_by_user_id=eq.${user.id}` // üöÄ CORRE√á√ÉO: Filtro rigoroso
      }, handleLeadUpdate)
      .subscribe((status) => {
        if (!isProduction) {
          console.log('[ChatsRealtime] üì° Status da subscription:', status);
        }
        
        if (status === 'SUBSCRIBED') {
          isSubscribedRef.current = true;
          statsRef.current.connectionStatus = 'connected';
          reconnectAttempts.current = 0; // Reset tentativas ap√≥s sucesso
        } else if (status === 'CHANNEL_ERROR') {
          console.error('[ChatsRealtime] ‚ùå Erro no canal de chats, tentando reconnection');
          isSubscribedRef.current = false;
          statsRef.current.connectionStatus = 'error';
          reconnect();
        } else if (status === 'CLOSED') {
          isSubscribedRef.current = false;
          statsRef.current.connectionStatus = 'disconnected';
        } else if (status === 'TIMED_OUT') {
          console.error('[ChatsRealtime] ‚è±Ô∏è Timeout, tentando reconnection');
          reconnect();
        }
      });

    channelRef.current = channel;
  }, [user?.id, activeInstanceId, handleNewLead, handleLeadUpdate, cleanup, reconnect]);

  // üöÄ CORRE√á√ÉO: Configurar subscription apenas quando usu√°rio estiver autenticado
  useEffect(() => {
    if (user?.id && activeInstanceId) {
      setupRealtime();
    } else {
      cleanup();
    }
  }, [user?.id, activeInstanceId, setupRealtime, cleanup]);

  // üöÄ CORRE√á√ÉO: Heartbeat para detectar conex√µes mortas
  useEffect(() => {
    if (!channelRef.current) return;
    
    const heartbeat = setInterval(() => {
      if (channelRef.current && channelRef.current.state === 'closed') {
        console.log('[ChatsRealtime] üíî Conex√£o morta detectada, reconnectando...');
        reconnect();
      }
    }, 30000); // Check a cada 30 segundos

    return () => clearInterval(heartbeat);
  }, [reconnect]);

  // Cleanup geral
  useEffect(() => {
    return () => {
      cleanup();
    };
  }, [cleanup]);

  return {
    isConnected: isSubscribedRef.current,
    connectionStatus: statsRef.current.connectionStatus,
    totalEvents: statsRef.current.totalEvents,
    lastUpdate: statsRef.current.lastUpdate,
    reconnectAttempts: reconnectAttempts.current,
    forceDisconnect: cleanup
  };
};
