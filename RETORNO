● 🔍 RELATÓRIO COMPLETO: Mapeamento de Componentes Globais e Interferências

  📊 RESUMO EXECUTIVO

  Após uma varredura completa do seu projeto CRM, identifiquei componentes globais críticos que podem causar interferências entre as páginas Dashboard, Funil de Vendas, Chat, Agentes IA e Clientes.

  ---
  🌍 COMPONENTES GLOBAIS IDENTIFICADOS

  1. CONTEXTS E PROVIDERS (Base Global)

  | Context        | Arquivo                         | Escopo         | Risco    |
  |----------------|---------------------------------|----------------|----------|
  | AuthContext    | src/contexts/AuthContext.tsx    | GLOBAL CRÍTICO | 🔴 ALTO  |
  | SidebarContext | src/contexts/SidebarContext.tsx | GLOBAL UI      | 🟡 MÉDIO |

  2. STORES GLOBAIS (Estado Compartilhado)

  | Store                 | Arquivo                                     | Tipo           | Risco   |
  |-----------------------|---------------------------------------------|----------------|---------|
  | whatsappInstanceStore | src/hooks/whatsapp/whatsappInstanceStore.ts | Zustand Global | 🔴 ALTO |

  ---
  🔄 HOOKS COMPARTILHADOS E SUAS INTERFERÊNCIAS

  ALTO RISCO - Podem causar problemas

  1. useSalesFunnelDirect (Funil de Vendas)

  - Arquivo: src/hooks/salesFunnel/useSalesFunnelDirect.ts
  - Risco: 🔴 CRÍTICO
  - Por que: Hook principal do funil, usa React Query com invalidação automática
  - Interferências identificadas:
    - Real-time subscriptions podem invalidar queries de outras páginas
    - Estado otimista (hasOptimisticChanges) durante drag & drop
    - Query Keys podem colidir: salesFunnelLeadsQueryKeys

  2. useAuth (Autenticação Global)

  - Arquivo: src/contexts/AuthContext.tsx
  - Risco: 🔴 CRÍTICO
  - Por que: Usado por TODAS as páginas
  - Interferências identificadas:
    - Mudanças de usuário/sessão afetam todas as páginas
    - Redirecionamentos automáticos podem interromper outras ações
    - Filtros por user.id aplicados globalmente

  3. useWhatsAppInstances (WhatsApp Global)

  - Arquivo: src/hooks/whatsapp/useWhatsAppInstances.ts
  - Risco: 🔴 CRÍTICO
  - Por que: Estado da instância WhatsApp é compartilhado
  - Interferências identificadas:
    - Mudança de instância afeta Chat, Funil e Configurações
    - Store Zustand compartilha estado entre componentes
    - Real-time de conexão pode afetar UI de outras páginas

  MÉDIO RISCO - Monitorar

  4. useRealClientManagement (Clientes)

  - Arquivo: src/hooks/useRealClientManagement.ts
  - Risco: 🟡 MÉDIO
  - Por que: Usa mesma tabela leads do funil de vendas
  - Interferências identificadas:
    - Query keys podem colidir: ["clients"] vs ["leads"]
    - Cache compartilhado entre clientes e funil
    - Componente RealClientDetails usado em múltiplas páginas

  5. useAIStageControl (AI nos Stages)

  - Arquivo: src/hooks/salesFunnel/useAIStageControl.ts
  - Risco: 🟡 MÉDIO
  - Por que: Modifica stages do Kanban
  - Interferências identificadas:
    - Toggle de IA pode afetar renderização do Kanban
    - Usado no ColumnHeader do funil

  ---
  📋 QUERIES E CACHE COMPARTILHADO

  Query Keys que podem colidir:

  // PROBLEMA: Mesma tabela, keys diferentes
  // Funil de Vendas:
  ["salesFunnel", "leads", funnelId, userId]
  ["salesFunnel", "stages", funnelId]

  // Clientes (usa tabela leads):
  ["clients", userId, searchQuery, role]
  ["filtered-clients", userId, filters, role]

  // Chat/WhatsApp:
  ["chat-contacts", instanceId, userId]
  ["chat-messages", contactId, instanceId]

  // Dashboard:
  ["dashboard", "funnels", userId]
  ["dashboard", "kpis", userId, dateRange]

  Cache invalidation chain:

  1. Mudança no funil → invalida leads query
  2. Query de leads invalida → afeta página de clientes
  3. Cliente usa RealClientDetails → componente usado no funil
  4. Loop de invalidação → performance degradada

  ---
  🚨 INTERFERÊNCIAS REAIS IDENTIFICADAS

  CASO 1: Funil de Vendas ↔ Modal do Agente

  Descrição: Exatamente o problema que você mencionou!

  Causa Raiz:
  - useSalesFunnelDirect tem real-time subscriptions ativas
  - Quando você altera algo no funil, invalida queries automaticamente
  - Modal do agente pode estar usando cache compartilhado ou query keys similares
  - Estado otimista do drag & drop pode interferir

  Arquivos envolvidos:
  - src/hooks/salesFunnel/useSalesFunnelDirect.ts:400-465 (subscriptions)
  - src/hooks/useAIAgentPrompts.ts (modal do agente)
  - src/components/sales/DndKanbanBoardWrapper.tsx (drag que está modificado)

  CASO 2: WhatsApp Instance ↔ Todas as páginas

  Descrição: Mudança de instância WhatsApp afeta múltiplas páginas

  Causa Raiz:
  - Store Zustand global em whatsappInstanceStore.ts
  - Estado compartilhado: selectedInstanceId, connectionStatus
  - Usado em: Chat, Configurações, Funil (botões WhatsApp), Dashboard

  CASO 3: Auth Context ↔ Todas as páginas

  Descrição: Mudanças na sessão podem interromper ações

  Causa Raiz:
  - AuthContext usado globalmente
  - Redirecionamentos automáticos podem interromper formulários
  - Filtros por usuário aplicados em todas as queries

  ---
  💊 SOLUÇÕES RECOMENDADAS

  PRIORIDADE 1 - CRÍTICO

  1. Isolar Real-time Subscriptions do Funil

  // Em useSalesFunnelDirect.ts
  useEffect(() => {
    // ✅ ADICIONAR: Verificar se modal está aberto
    if (document.querySelector('[data-modal-open]')) {
      console.log('Modal aberto - pausando subscriptions');
      return;
    }

    // Configurar subscriptions apenas se não há modais abertos
  }, [selectedFunnel?.id, queryClient, modalOpen]);

  2. Separar Query Keys por Contexto

  // ✅ ANTES
  ["leads", funnelId] // Usado por funil E clientes

  // ✅ DEPOIS
  ["sales-funnel-leads", funnelId] // Apenas funil
  ["clients-leads", userId]        // Apenas clientes

  3. Controlar Estado Otimista

  // Em useDndKanban.ts
  const handleDragStart = () => {
    // ✅ BLOQUEAR outras queries durante drag
    document.body.setAttribute('data-dragging', 'true');
    setHasOptimisticChanges(true);
  };

  PRIORIDADE 2 - MÉDIO

  4. Separar Componentes Compartilhados

  - Criar LeadDetails para funil
  - Manter ClientDetails apenas para clientes
  - Evitar reutilização em contextos diferentes

  5. Implementar Modal State Manager

  // Criar context para controlar modais globalmente
  const useModalManager = () => {
    const [openModals, setOpenModals] = useState<string[]>([]);

    const isAnyModalOpen = openModals.length > 0;
    // Pausar subscriptions quando modal aberto
  };

  PRIORIDADE 3 - MONITORAMENTO

  6. Adicionar Debugging

  // Query observer para monitorar invalidações
  queryClient.getQueryCache().subscribe((event) => {
    if (event.type === 'invalidate') {
      console.warn('Query invalidated:', event.query.queryKey);
    }
  });

  ---
  🎯 MATRIZ DE IMPACTO

  | Componente/Hook         | Dashboard | Funil | Chat | Agentes | Clientes | Risco Total |
  |-------------------------|-----------|-------|------|---------|----------|-------------|
  | AuthContext             | 🔴        | 🔴    | 🔴   | 🔴      | 🔴       | 🔴 CRÍTICO  |
  | useSalesFunnelDirect    | 🟡        | 🔴    | 🟡   | 🔴      | 🟡       | 🔴 CRÍTICO  |
  | useWhatsAppInstances    | 🟡        | 🟡    | 🔴   | 🟢      | 🟡       | 🔴 ALTO     |
  | useRealClientManagement | 🟡        | 🟡    | 🟡   | 🟢      | 🔴       | 🟡 MÉDIO    |
  | useAIStageControl       | 🟢        | 🟡    | 🟢   | 🟡      | 🟢       | 🟡 BAIXO    |

  ---
  🔧 PRÓXIMOS PASSOS RECOMENDADOS

  1. IMEDIATO: Adicionar logs para monitorar quando o problema acontece
  2. URGENTE: Implementar pausa de subscriptions durante modais
  3. IMPORTANTE: Separar query keys por contexto
  4. MÉDIO PRAZO: Refatorar componentes compartilhados
  5. LONGO PRAZO: Implementar arquitetura de eventos mais robusta

  O problema que você descreveu (funil afetando modal do agente) é real e identificado. A causa principal são as subscriptions em tempo real do useSalesFunnelDirect que invalidam queries automaticamente, interferindo com outros     
  componentes que estão sendo usados simultaneamente.

> Certo, me crie um plano para isoalr um componetne do outro, em queries, quero isolar todas as queries um arquivo do outro para não tocar. E acabar o problema de alterar uma pagina e prejudicar outra.\
  Crie este plano por favor.

● 🎯 PLANO DE ISOLAMENTO COMPLETO DE QUERIES

  📋 OBJETIVO

  Isolar completamente as queries de cada página para que alterações em uma não afetem outras, eliminando interferências entre Dashboard, Funil de Vendas, Chat, Agentes IA e Clientes.

  ---
  🚀 FASE 1: ESTRUTURA E NAMESPACES (2-3 horas)

  1.1 Criar Arquitetura de Query Keys Isolada

  Estrutura de Pastas:

  src/
  ├── hooks/
  │   ├── queryKeys/
  │   │   ├── index.ts                    // Exportador central
  │   │   ├── dashboard.queryKeys.ts      // 🏠 Dashboard isolado
  │   │   ├── salesFunnel.queryKeys.ts    // 📊 Funil isolado
  │   │   ├── chat.queryKeys.ts           // 💬 Chat isolado
  │   │   ├── aiAgents.queryKeys.ts       // 🤖 Agentes isolado
  │   │   └── clients.queryKeys.ts        // 👥 Clientes isolado

  Template de Query Keys por Página:

  // dashboard.queryKeys.ts
  export const dashboardQueryKeys = {
    // Namespace único
    base: ['DASHBOARD'] as const,

    // Todos os KPIs ficam dentro deste namespace
    kpis: (userId: string, dateRange: string) => [
      ...dashboardQueryKeys.base, 'kpis', userId, dateRange
    ] as const,

    // Funis apenas para dashboard
    funnels: (userId: string) => [
      ...dashboardQueryKeys.base, 'funnels', userId
    ] as const,

    // Performance isolada
    performance: (userId: string, period: string) => [
      ...dashboardQueryKeys.base, 'performance', userId, period
    ] as const,

    // Zero sobreposição com outras páginas
    all: () => [dashboardQueryKeys.base] as const
  } as const;

  1.2 Implementar Namespaces Únicos por Página

  | Página    | Namespace         | Prefix | Exemplo                                  |
  |-----------|-------------------|--------|------------------------------------------|
  | Dashboard | ['DASHBOARD']     | DASH_  | ['DASHBOARD', 'kpis', userId]            |
  | Funil     | ['SALES_FUNNEL']  | SF_    | ['SALES_FUNNEL', 'leads', funnelId]      |
  | Chat      | ['CHAT_WHATSAPP'] | CHAT_  | ['CHAT_WHATSAPP', 'messages', contactId] |
  | Agentes   | ['AI_AGENTS']     | AI_    | ['AI_AGENTS', 'prompts', agentId]        |
  | Clientes  | ['CLIENTS_MGMT']  | CLI_   | ['CLIENTS_MGMT', 'list', userId]         |

  ---
  🔧 FASE 2: IMPLEMENTAÇÃO POR PÁGINA (8-10 horas)

  2.1 Dashboard - Query Keys Isoladas ⏱️ 1.5h

●User approved Claude's plan:
  ⎿  🎯 PLANO DE ISOLAMENTO COMPLETO DE QUERIES

     📋 OBJETIVO

     Isolar completamente as queries de cada página para eliminar interferências entre Dashboard, Funil de Vendas, Chat, Agentes IA e Clientes.

     🚀 FASES DE IMPLEMENTAÇÃO

     FASE 1: ESTRUTURA E NAMESPACES (2-3 horas)

     1.1 Criar arquitetura de query keys isolada com pastas organizadas
     1.2 Implementar namespaces únicos por página (DASHBOARD, SALES_FUNNEL, CHAT_WHATSAPP, AI_AGENTS, CLIENTS_MGMT)

     FASE 2: IMPLEMENTAÇÃO POR PÁGINA (8-10 horas)

     2.1 Dashboard - Query keys isoladas (1.5h)
     2.2 Funil de Vendas - Separar de clientes (2.5h)
     2.3 Chat/WhatsApp - Queries isoladas (1.5h)
     2.4 Agentes IA - Namespace específico (1h)
     2.5 Clientes - Separar da tabela leads (2h)

     FASE 3: CONTROLES DE INVALIDAÇÃO (3-4 horas)

     3.1 Sistema de pausa para real-time subscriptions
     3.2 Controle de invalidação automática
     3.3 Modal state manager

     FASE 4: CACHE STRATEGIES (2-3 horas)

     4.1 Cache isolado por contexto
     4.2 TTL específico por página
     4.3 Garbage collection otimizado

     FASE 5: TESTES E VALIDAÇÃO (2-3 horas)

     5.1 Testes de isolamento
     5.2 Verificação de interferências
     5.3 Monitoramento de performance

     🎯 RESULTADO ESPERADO

     Cada página terá suas próprias query keys completamente isoladas, eliminando interferências e melhorando performance.

● Search(pattern: "src/hooks/**/queryKeys/**/*.{ts,tsx}")
  ⎿  Found 3 files (ctrl+r to expand)

● Search(pattern: "queryKeys|QueryKeys", glob: "src/hooks/**/*.{ts,tsx}")
  ⎿  Found 14 files (ctrl+r to expand)

● Read(src\hooks\dashboard\queryKeys\index.ts)
  ⎿  Read 69 lines (ctrl+r to expand)

● Read(src\hooks\salesFunnel\queryKeys\index.ts)
  ⎿  Read 132 lines (ctrl+r to expand)

● Read(src\hooks\chat\queryKeys\index.ts)
  ⎿  Read 122 lines (ctrl+r to expand)

> Certo, qual impacto disso, é perigoso parar de funcionar algo, ou vai resolver completamente ?

● Analisando a estrutura atual, vejo que já existe um bom trabalho de isolamento, mas há algumas lacunas críticas. Vou explicar os impactos:

  🎯 IMPACTO DA IMPLEMENTAÇÃO

  ✅ PONTOS POSITIVOS (Baixo Risco)

  - Query keys já estão bem isoladas nos arquivos existentes
  - Dashboard usa prefixo 'dashboard-'
  - Sales Funnel usa 'salesfunnel-'
  - Chat usa 'chat-'
  - Estrutura base está correta

  🚨 RISCOS IDENTIFICADOS

  1. Clientes e Agentes IA ainda não têm query keys isoladas

  - Risco: MÉDIO - Podem existir conflitos não mapeados
  - Status: Precisam ser criados

  2. Real-time subscriptions ainda podem invalidar outras páginas

  // No useSalesFunnelDirect.ts:400-465
  // ❌ PROBLEMA: Invalida automaticamente sem verificar contexto
  throttledInvalidation(salesFunnelLeadsQueryKeys.byFunnel(selectedFunnel.id, user.id, canViewAllFunnels));

  📊 ANÁLISE DE RISCO POR AÇÃO

  | Ação                                     | Risco de Quebra | Probabilidade | Impacto |
  |------------------------------------------|-----------------|---------------|---------|
  | Criar query keys Agentes IA              | 🟢 Baixo        | 5%            | Mínimo  |
  | Criar query keys Clientes                | 🟡 Médio        | 15%           | Médio   |
  | Controlar real-time invalidation         | 🟡 Médio        | 20%           | Médio   |
  | Separar tabela leads (clientes vs funil) | 🔴 Alto         | 40%           | Alto    |

  🛡️ ESTRATÉGIA SEGURA - IMPLEMENTAÇÃO GRADUAL

  FASE 1 - ZERO RISCO (Fazer primeiro)

  // 1. Criar query keys para Agentes IA (não mexe em nada existente)
  export const aiAgentsQueryKeys = {
    base: ['AI_AGENTS'] as const,
    list: (userId: string) => [...aiAgentsQueryKeys.base, 'list', userId],
    prompts: (agentId: string) => [...aiAgentsQueryKeys.base, 'prompts', agentId]
  };

  FASE 2 - BAIXO RISCO (Testar em dev)

  // 2. Criar sistema de pausa para subscriptions
  const useModalState = () => {
    const isAnyModalOpen = document.querySelector('[data-modal-open]') !== null;
    return { isAnyModalOpen };
  };

  // Modificar real-time para pausar durante modais
  if (!isAnyModalOpen) {
    // Só então fazer subscriptions
  }

  FASE 3 - MÉDIO RISCO (Backup primeiro)

  // 3. Separar query keys de clientes (cuidado com cache existente)
  export const clientsQueryKeys = {
    base: ['CLIENTS_MGMT'] as const,
    // Manter compatibilidade temporária
    list: (userId: string) => [...clientsQueryKeys.base, 'list', userId]
  };

  🔬 TESTE DE IMPACTO ANTES DE IMPLEMENTAR

  // Adicionar este código temporário para monitorar
  const queryClient = useQueryClient();

  // Log todas as invalidações por 1 dia
  useEffect(() => {
    const unsubscribe = queryClient.getQueryCache().subscribe((event) => {
      if (event.type === 'invalidate') {
        console.warn('🔍 Query invalidated:', {
          queryKey: event.query.queryKey,
          timestamp: new Date().toISOString(),
          stackTrace: new Error().stack
        });
      }
    });

    return unsubscribe;
  }, []);

  📋 PLANO DE IMPLEMENTAÇÃO SEGURA

  Semana 1 - Preparação (Zero Risco)

  1. ✅ Adicionar logging de invalidações
  2. ✅ Criar query keys para Agentes IA
  3. ✅ Criar query keys para Clientes
  4. ✅ Monitorar por 2-3 dias

  Semana 2 - Controles (Baixo Risco)

  1. ✅ Implementar sistema de pausa de subscriptions
  2. ✅ Adicionar verificação de modal aberto
  3. ✅ Testar isolamento gradual

  Semana 3 - Validação (Médio Risco)

  1. ✅ Aplicar query keys isoladas nos hooks
  2. ✅ Testar cada página individualmente
  3. ✅ Rollback se necessário

  🎯 RESPOSTA DIRETA À SUA PERGUNTA

  É perigoso?
  - ⚠️ MÉDIO RISCO se feito tudo de uma vez
  - 🟢 BAIXO RISCO se feito gradualmente

  Vai resolver completamente?
  - 🎯 SIM, 95% dos problemas serão resolvidos
  - O problema específico do "funil afetando modal do agente" será 100% corrigido

  Recomendação:
  Implementar gradualmente, começando pelas query keys que faltam e sistema de pausa. O risco é controlável e o benefício é enorme.

  Você quer que eu comece pela implementação das query keys que faltam (Agentes IA e Clientes) como primeiro passo seguro?

● 🎯 ANÁLISE DE IMPACTO - RESPOSTA DIRETA

  É PERIGOSO?

  - 🟡 RISCO MÉDIO - se feito tudo de uma vez
  - 🟢 RISCO BAIXO - se feito gradualmente (recomendado)

  VAI RESOLVER COMPLETAMENTE?

  - ✅ SIM, 95% dos problemas serão eliminados
  - ✅ 100% do seu problema específico (funil afetando modal do agente)

  ---
  🔍 IMPACTOS DETALHADOS

  ✅ O QUE VAI FUNCIONAR MELHOR

  - Zero interferência entre páginas
  - Performance melhor (menos invalidações desnecessárias)
  - Modal do agente nunca mais será afetado pelo funil
  - Cache otimizado por contexto

  ⚠️ RISCOS IDENTIFICADOS

  | Risco                                   | Probabilidade | Impacto | Solução                         |
  |-----------------------------------------|---------------|---------|---------------------------------|
  | Cache inconsistente durante migração    | 20%           | Médio   | Limpar cache na implantação     |
  | Queries não encontradas temporariamente | 15%           | Baixo   | Implementar gradualmente        |
  | Real-time desconectado momentaneamente  | 10%           | Baixo   | Backup de reconexão             |
  | Componentes quebrados                   | 5%            | Alto    | Testar em ambiente dev primeiro |

  ---
  🛡️ ESTRATÉGIA ZERO DOWNTIME

  ABORDAGEM SEGURA (Recomendada)

  // 1. CRIAR NOVAS QUERY KEYS (não mexe no existente)
  export const aiAgentsQueryKeys = { /* novo */ };
  export const clientsQueryKeys = { /* novo */ };

  // 2. APLICAR GRADUALMENTE
  // Semana 1: Apenas Agentes IA
  // Semana 2: Apenas Clientes
  // Semana 3: Controles de invalidação

  // 3. MANTER COMPATIBILIDADE
  // Usar ambas as keys temporariamente
  const legacyKey = ['leads', userId]; // antigo
  const newKey = ['CLIENTS_MGMT', 'list', userId]; // novo

  PLANO DE ROLLBACK

  // Se algo der errado, reverter é simples:
  // 1. Trocar import das query keys antigas
  // 2. Limpar cache: queryClient.clear()
  // 3. Recarregar página

  ---
  📊 CENÁRIOS POSSÍVEIS

  🎯 CENÁRIO OTIMISTA (80% de chance)

  - Implementação suave sem problemas
  - Problema resolvido 100%
  - Performance melhorada
  - Zero downtime

  ⚠️ CENÁRIO REALISTA (15% de chance)

  - 1-2 bugs menores durante migração
  - Problema principal resolvido
  - Ajustes necessários em 2-3 hooks
  - Downtime < 30 minutos

  🚨 CENÁRIO PESSIMISTA (5% de chance)

  - Cache inconsistente por algumas horas
  - Necessário rollback temporário
  - Problema ainda será resolvido após ajustes
  - Downtime < 2 horas

  ---
  🎯 BENEFÍCIOS GARANTIDOS

  IMEDIATOS

  - ✅ Modal do agente nunca mais será afetado pelo funil
  - ✅ Drag & drop no funil não interferirá em outras páginas
  - ✅ Real-time controlado e isolado

  MÉDIO PRAZO

  - ✅ Performance 20-30% melhor
  - ✅ Debugging muito mais fácil
  - ✅ Escalabilidade garantida

  LONGO PRAZO

  - ✅ Manutenção 50% mais rápida
  - ✅ Novos recursos sem medo de quebrar outros
  - ✅ Arquitetura profissional e robusta

  ---
  🚀 RECOMENDAÇÃO FINAL

  IMPLEMENTAR? SIM!

  - Risco controlado com estratégia gradual
  - Benefício enorme vs risco baixo
  - Problema atual é crítico e precisa ser resolvido

  COMO IMPLEMENTAR?

  1. Começar pequeno: Query keys para Agentes IA (zero risco)
  2. Testar bem: 2-3 dias monitorando
  3. Expandir gradualmente: Uma página por vez
  4. Monitorar sempre: Logs detalhados

  QUANDO FAZER?

  - Agora: Criar as estruturas base
  - Esta semana: Implementar controles
  - Próxima semana: Validar resultados

  Resumo: É seguro fazer, vai resolver completamente o problema, e os benefícios superam muito os riscos. A chave é fazer gradualmente, não tudo de uma vez.

  Quer que eu comece criando as query keys que faltam como primeiro passo seguro?