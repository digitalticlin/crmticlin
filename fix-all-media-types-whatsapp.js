#!/usr/bin/env node

const fs = require('fs');

console.log('üì± CORRE√á√ÉO COMPLETA - TODOS OS TIPOS DE M√çDIA WHATSAPP\n');

const serverPath = '/root/whatsapp-server/server.js';

if (!fs.existsSync(serverPath)) {
  console.error('‚ùå server.js n√£o encontrado!');
  process.exit(1);
}

let serverContent = fs.readFileSync(serverPath, 'utf8');

console.log('üîç Aplicando corre√ß√µes para todos os tipos de m√≠dia...');

// NOVO SWITCH CASE COMPLETO COM TODOS OS TIPOS DE M√çDIA
const newMediaSwitch = `      switch (baseType.toLowerCase()) {
        case 'image':
           if (mediaUrl.startsWith('data:')) {
             // ‚úÖ DataURL ‚Üí Buffer (para Baileys)
             console.log('üñºÔ∏è Convertendo imagem DataURL para Buffer...');
             const base64Data = mediaUrl.split(',')[1];
             const buffer = Buffer.from(base64Data, 'base64');
             messageResult = await instance.socket.sendMessage(formattedPhone, {
               image: buffer,
               fileName: message.trim() || 'image.jpg'
             });
           } else {
             // URL HTTP normal
             messageResult = await instance.socket.sendMessage(formattedPhone, {
               image: { url: mediaUrl },
               fileName: message.trim() || 'image.jpg'
             });
           }
           break;

        case 'video':
          if (mediaUrl.startsWith('data:')) {
            // ‚úÖ DataURL ‚Üí Buffer para v√≠deos
            console.log('üìπ Convertendo v√≠deo DataURL para Buffer...');
            const base64Data = mediaUrl.split(',')[1];
            const buffer = Buffer.from(base64Data, 'base64');
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              video: buffer,
              fileName: message.trim() || 'video.mp4'
            });
          } else {
            // URL HTTP normal
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              video: { url: mediaUrl },
              caption: message
            });
          }
          break;

        case 'audio':
          if (mediaUrl.startsWith('data:')) {
            // ‚úÖ DataURL ‚Üí Buffer para √°udios
            console.log('üéµ Convertendo √°udio DataURL para Buffer...');
            const base64Data = mediaUrl.split(',')[1];
            const buffer = Buffer.from(base64Data, 'base64');
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              audio: buffer,
              fileName: message.trim() || 'audio.mp3',
              mimetype: 'audio/mpeg'
            });
          } else {
            // URL HTTP normal
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              audio: { url: mediaUrl },
              ptt: true
            });
          }
          break;

        case 'document':
          if (mediaUrl.startsWith('data:')) {
            // ‚úÖ DataURL ‚Üí Buffer para documentos
            console.log('üìÑ Convertendo documento DataURL para Buffer...');
            const base64Data = mediaUrl.split(',')[1];
            const buffer = Buffer.from(base64Data, 'base64');
            
            // Detectar MIME type baseado no DataURL
            const mimeMatch = mediaUrl.match(/data:([^;]+)/);
            const mimeType = mimeMatch ? mimeMatch[1] : 'application/octet-stream';
            
            // Extens√£o baseada no MIME type
            let extension = '.bin';
            if (mimeType.includes('pdf')) extension = '.pdf';
            else if (mimeType.includes('word')) extension = '.docx';
            else if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) extension = '.xlsx';
            else if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) extension = '.pptx';
            else if (mimeType.includes('text')) extension = '.txt';
            else if (mimeType.includes('zip')) extension = '.zip';
            else if (mimeType.includes('rar')) extension = '.rar';
            
            const fileName = message.trim() || \`documento\${extension}\`;
            
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              document: buffer,
              fileName: fileName,
              mimetype: mimeType
            });
          } else {
            // URL HTTP normal
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              document: { url: mediaUrl },
              fileName: message.trim() || 'documento.pdf',
              mimetype: 'application/pdf'
            });
          }
          break;

        // ‚úÖ NOVOS TIPOS ADICIONADOS
        case 'sticker':
          if (mediaUrl.startsWith('data:')) {
            console.log('üè∑Ô∏è Convertendo sticker DataURL para Buffer...');
            const base64Data = mediaUrl.split(',')[1];
            const buffer = Buffer.from(base64Data, 'base64');
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              sticker: buffer
            });
          } else {
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              sticker: { url: mediaUrl }
            });
          }
          break;

        case 'gif':
          if (mediaUrl.startsWith('data:')) {
            console.log('üéûÔ∏è Convertendo GIF DataURL para Buffer...');
            const base64Data = mediaUrl.split(',')[1];
            const buffer = Buffer.from(base64Data, 'base64');
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              video: buffer,
              gifPlayback: true,
              fileName: message.trim() || 'animation.gif'
            });
          } else {
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              video: { url: mediaUrl },
              gifPlayback: true
            });
          }
          break;

        case 'voice':
        case 'ptt':
          if (mediaUrl.startsWith('data:')) {
            console.log('üéôÔ∏è Convertendo √°udio de voz DataURL para Buffer...');
            const base64Data = mediaUrl.split(',')[1];
            const buffer = Buffer.from(base64Data, 'base64');
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              audio: buffer,
              ptt: true,
              mimetype: 'audio/ogg; codecs=opus'
            });
          } else {
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              audio: { url: mediaUrl },
              ptt: true
            });
          }
          break;

        case 'location':
          // Localiza√ß√£o n√£o usa DataURL, mas coordenadas
          const [latitude, longitude] = (mediaUrl || '0,0').split(',').map(parseFloat);
          messageResult = await instance.socket.sendMessage(formattedPhone, {
            location: {
              degreesLatitude: latitude,
              degreesLongitude: longitude
            }
          });
          break;

        case 'contact':
          // Contato via vCard
          if (mediaUrl.startsWith('data:text/vcard') || mediaUrl.startsWith('BEGIN:VCARD')) {
            const vCardData = mediaUrl.startsWith('data:') 
              ? Buffer.from(mediaUrl.split(',')[1], 'base64').toString('utf8')
              : mediaUrl;
            
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              contacts: {
                displayName: message.trim() || 'Contato',
                contacts: [{ vcard: vCardData }]
              }
            });
          } else {
            // Fallback para texto
            messageResult = await instance.socket.sendMessage(formattedPhone, {
              text: \`Contato: \${message}\\nTelefone: \${mediaUrl}\`
            });
          }
          break;

        default:
          console.log(\`‚ö†Ô∏è Tipo de m√≠dia n√£o reconhecido: \${mediaType}, enviando como texto\`);
          messageResult = await instance.socket.sendMessage(formattedPhone, {
            text: message
          });
          break;
      }`;

// Encontrar e substituir o switch case completo
const switchRegex = /switch \(baseType\.toLowerCase\(\)\) \{[\s\S]*?default:[\s\S]*?break;\s*\}/;

if (switchRegex.test(serverContent)) {
  serverContent = serverContent.replace(switchRegex, newMediaSwitch);
  console.log('‚úÖ Switch case de m√≠dia substitu√≠do completamente!');
} else {
  console.log('‚ö†Ô∏è Switch case n√£o encontrado no formato esperado');
  
  // Tentar encontrar apenas a se√ß√£o de switch
  const altSwitchRegex = /switch \(baseType\.toLowerCase\(\)\) \{[\s\S]*?\}/;
  if (altSwitchRegex.test(serverContent)) {
    serverContent = serverContent.replace(altSwitchRegex, newMediaSwitch);
    console.log('‚úÖ Switch case corrigido com busca alternativa!');
  } else {
    console.error('‚ùå N√£o foi poss√≠vel encontrar switch case para m√≠dia');
    console.log('üîç Procurando por qualquer switch...');
    
    // √öltima tentativa - procurar qualquer case 'image'
    const imageRegex = /case 'image':[\s\S]*?break;/;
    if (imageRegex.test(serverContent)) {
      // Substituir toda a √°rea de cases
      const fullCaseRegex = /(case 'image':[\s\S]*?)(\s*}\s*else)/;
      const match = serverContent.match(fullCaseRegex);
      if (match) {
        serverContent = serverContent.replace(match[1], newMediaSwitch + '\n        ');
        console.log('‚úÖ Cases de m√≠dia substitu√≠dos com busca manual!');
      }
    } else {
      console.error('‚ùå Imposs√≠vel localizar se√ß√£o de m√≠dia');
      process.exit(1);
    }
  }
}

// Salvar
fs.writeFileSync(serverPath, serverContent, 'utf8');

console.log('\nüéâ CORRE√á√ÉO COMPLETA APLICADA COM SUCESSO!');
console.log('\nüìã TIPOS DE M√çDIA SUPORTADOS:');
console.log('   üì∑ image (jpg, png, webp)');
console.log('   üìπ video (mp4, avi, mov)');
console.log('   üéµ audio (mp3, wav, ogg)');
console.log('   üìÑ document (pdf, docx, xlsx, pptx, txt, zip)');
console.log('   üè∑Ô∏è sticker (webp, png)');
console.log('   üéûÔ∏è gif (anima√ß√µes)');
console.log('   üéôÔ∏è voice/ptt (√°udio de voz)');
console.log('   üìç location (coordenadas)');
console.log('   üë§ contact (vCard)');

console.log('\nüîß FUNCIONALIDADES:');
console.log('   ‚úÖ DataURL ‚Üí Buffer (todos os tipos)');
console.log('   ‚úÖ URL HTTP normal (fallback)');
console.log('   ‚úÖ Detec√ß√£o autom√°tica de MIME type');
console.log('   ‚úÖ Extens√µes corretas por tipo');
console.log('   ‚úÖ Nomes de arquivo inteligentes');

console.log('\nüîÑ Reiniciando PM2...');

const { exec } = require('child_process');
exec('pm2 restart whatsapp-server', (error, stdout, stderr) => {
  if (error) {
    console.error('‚ùå Erro ao reiniciar PM2:', error.message);
    console.log('\n‚ö†Ô∏è Reinicie manualmente: pm2 restart whatsapp-server');
    return;
  }
  
  console.log('‚úÖ Servidor reiniciado!');
  console.log('\nüöÄ AGORA SUA VPS SUPORTA TODOS OS TIPOS DE M√çDIA!');
  console.log('üì± Teste envio de: v√≠deos, √°udios, documentos, GIFs, stickers...');
}); 